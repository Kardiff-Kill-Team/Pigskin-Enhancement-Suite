This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-08T05:17:05.484Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
modules/
  utils/
    path-validator.js
    storage-utils.js
    ui-utils.js
  lock-module-continued.js
  lock-module.js
  picks-history-module.js
  picks-module.js
  spreads-module.js
  standings-module.js
  time-module.js
  user-id-module.js
  wiki-team-module.js
.repomixignore
LICENSE.md
main-script.js
README.md
repo-structure.md
repomix.config.json

================================================================
Repository Files
================================================================

================
File: modules/utils/path-validator.js
================
// pathValidator.js
const pathValidator = {
    REPO_BASE: 'Kardiff-Kill-Team/Pigskin-Enhancement-Suite',
    REPO_RAW_BASE: 'https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main',
    
    validatePaths(moduleContent) {
        const issues = [];
        
        // Check for old repository names
        if (moduleContent.includes('pigskin-enhancements')) {
            issues.push('Found old repository name: pigskin-enhancements');
        }
        
        // Check @require statements
        const requirePattern = /@require\s+(https:\/\/raw\.githubusercontent\.com\/[^/]+\/[^/]+\/[^/]+\/.*)/g;
        const requires = [...moduleContent.matchAll(requirePattern)];
        requires.forEach(match => {
            if (!match[1].startsWith(this.REPO_RAW_BASE)) {
                issues.push(`Invalid @require path: ${match[1]}`);
            }
        });
        
        // Check for raw.githubusercontent.com URLs
        const urlPattern = /https:\/\/raw\.githubusercontent\.com\/[^/'"]+\/[^/'"]+\/[^/'"]+\/[^'"]+/g;
        const urls = [...moduleContent.matchAll(urlPattern)];
        urls.forEach(match => {
            if (!match[0].startsWith(this.REPO_RAW_BASE)) {
                issues.push(`Invalid raw URL: ${match[0]}`);
            }
        });
        
        // Check for repository references
        const repoPattern = /github\.com\/[^/'"]+\/[^/'"]+/g;
        const repos = [...moduleContent.matchAll(repoPattern)];
        repos.forEach(match => {
            if (!match[0].includes(this.REPO_BASE)) {
                issues.push(`Invalid repository reference: ${match[0]}`);
            }
        });
        
        return issues;
    },

    generateCorrectPath(oldPath) {
        // Convert any old path to the correct new path
        return oldPath.replace(
            /github\.com\/[^/]+\/[^/]+/,
            `github.com/${this.REPO_BASE}`
        );
    }
};

window.pathValidator = pathValidator;

================
File: modules/utils/storage-utils.js
================
const storageUtils = {
    async initialize() {
        // Initialize storage structure if needed
        const structure = await GM.getValue('storageStructure', null);
        if (!structure) {
            await this.initializeStorage();
        }
    },

    async initializeStorage() {
        const initialStructure = {
            version: '1.0.0',
            lastUpdate: Date.now(),
            data: {
                picks: {},
                spreads: {},
                settings: {},
                userId: null
            }
        };
        await GM.setValue('storageStructure', initialStructure);
    },

    async get(key, defaultValue = null) {
        try {
            return await GM.getValue(key, defaultValue);
        } catch (error) {
            console.error('Storage get error:', error);
            return defaultValue;
        }
    },

    async set(key, value) {
        try {
            await GM.setValue(key, value);
            return true;
        } catch (error) {
            console.error('Storage set error:', error);
            return false;
        }
    },

    async append(key, value) {
        try {
            const current = await this.get(key, []);
            if (Array.isArray(current)) {
                current.push(value);
                await this.set(key, current);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Storage append error:', error);
            return false;
        }
    },

    async update(key, updateFn) {
        try {
            const current = await this.get(key);
            const updated = updateFn(current);
            await this.set(key, updated);
            return true;
        } catch (error) {
            console.error('Storage update error:', error);
            return false;
        }
    },

    generateKey(...parts) {
        return parts.join('_');
    }
};

window.storageUtils = storageUtils;

================
File: modules/utils/ui-utils.js
================
const uiUtils = {
    async initialize() {
        this.addGlobalStyles();
    },

    addGlobalStyles() {
        const styles = `
            .psm-panel {
                position: fixed;
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 1000;
                font-family: Arial, sans-serif;
            }

            .psm-panel-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                border-bottom: 1px solid #dee2e6;
                background: #f8f9fa;
                border-radius: 8px 8px 0 0;
            }

            .psm-panel-content {
                padding: 15px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .psm-button {
                padding: 5px 10px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                background: #007bff;
                color: white;
            }

            .psm-button:hover {
                background: #0056b3;
            }

            .psm-button:disabled {
                background: #6c757d;
                cursor: not-allowed;
            }

            .psm-input {
                padding: 5px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 14px;
                width: 100%;
            }

            .psm-select {
                padding: 5px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 14px;
                width: 100%;
            }

            .psm-notification {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 20px;
                border-radius: 4px;
                color: white;
                font-size: 14px;
                z-index: 1001;
                animation: slideIn 0.3s ease-out;
            }

            @keyframes slideIn {
                from { transform: translateX(100%); }
                to { transform: translateX(0); }
            }

            .psm-notification.success { background: #28a745; }
            .psm-notification.error { background: #dc3545; }
            .psm-notification.warning { background: #ffc107; color: #000; }
            .psm-notification.info { background: #17a2b8; }

            .psm-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1002;
            }

            .psm-modal-content {
                background: white;
                padding: 20px;
                border-radius: 8px;
                max-width: 500px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
            }
        `;

        const styleSheet = document.createElement('style');
        styleSheet.textContent = styles;
        document.head.appendChild(styleSheet);
    },

    createPanel(options = {}) {
        const panel = document.createElement('div');
        panel.className = 'psm-panel';
        Object.assign(panel.style, {
            top: options.top || '20px',
            right: options.right || 'auto',
            left: options.left || 'auto',
            bottom: options.bottom || 'auto',
            width: options.width || '300px'
        });

        return panel;
    },

    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `psm-notification ${type}`;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => notification.remove(), 300);
        }, duration);
    },

    createModal(content, options = {}) {
        const modal = document.createElement('div');
        modal.className = 'psm-modal';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'psm-modal-content';
        
        if (typeof content === 'string') {
            modalContent.innerHTML = content;
        } else {
            modalContent.appendChild(content);
        }

        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        if (options.closeOnClick) {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        return {
            modal,
            close: () => modal.remove()
        };
    },

    formatDate(date) {
        return new Date(date).toLocaleString();
    },

    createElement(type, options = {}) {
        const element = document.createElement(type);
        
        if (options.className) {
            element.className = options.className;
        }
        
        if (options.text) {
            element.textContent = options.text;
        }
        
        if (options.html) {
            element.innerHTML = options.html;
        }
        
        if (options.attributes) {
            Object.entries(options.attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
        }
        
        if (options.styles) {
            Object.assign(element.style, options.styles);
        }
        
        return element;
    }
};

window.uiUtils = uiUtils;

================
File: modules/lock-module-continued.js
================
const lockModule = {
    // ... [previous code from last message]

    setupLockDropdown() {
        const lockDropdown = this.getLockDropdown();
        if (!lockDropdown) return;

        // Style the lock dropdown
        lockDropdown.classList.add('psm-select');
        lockDropdown.style.border = '2px solid #28a745';

        // Add change listener to regular dropdowns
        const gameDropdowns = Array.from(document.querySelectorAll('select'))
            .filter(dropdown => !this.isLockDropdown(dropdown));

        gameDropdowns.forEach(dropdown => {
            dropdown.addEventListener('change', () => {
                this.updateLockDropdown();
            });
        });

        // Add change listener to lock dropdown
        lockDropdown.addEventListener('change', () => {
            this.updateLockDisplay();
        });

        // Initial update
        this.updateLockDropdown();
    },

    getLockDropdown() {
        return Array.from(document.querySelectorAll('select'))
            .find(dropdown => this.isLockDropdown(dropdown));
    },

    isLockDropdown(dropdown) {
        return dropdown.name?.toLowerCase().includes('lock') ||
               dropdown.id?.toLowerCase().includes('lock');
    },

    updateLockDropdown() {
        const lockDropdown = this.getLockDropdown();
        if (!lockDropdown) return;

        const selectedTeams = this.getSelectedTeams();
        
        // Update all options in lock dropdown
        Array.from(lockDropdown.options).forEach(option => {
            const gameNumber = option.value;
            const selectedTeam = selectedTeams.get(gameNumber);

            if (!gameNumber) return; // Skip empty/default option

            if (selectedTeam) {
                // Enable and update text for selected teams
                option.disabled = false;
                option.classList.remove('disabled-option');
                option.textContent = `Game ${gameNumber}: ${selectedTeam}`;
                
                // Add spread information if available
                const spread = this.getSpreadForTeam(selectedTeam);
                if (spread) {
                    option.textContent += ` (${spread})`;
                }
            } else {
                // Disable and gray out unselected teams
                option.disabled = true;
                option.classList.add('disabled-option');
                option.textContent = `Game ${gameNumber}: (Make selection first)`;
            }
        });

        // If current selection is invalid, reset it
        if (lockDropdown.value && !selectedTeams.has(lockDropdown.value)) {
            lockDropdown.value = '';
        }

        this.updateLockDisplay();
    },

    getSelectedTeams() {
        const teams = new Map();
        
        // Get all dropdowns except the lock dropdown
        const gameDropdowns = Array.from(document.querySelectorAll('select'))
            .filter(dropdown => !this.isLockDropdown(dropdown));

        // Collect selected teams and their corresponding game numbers
        gameDropdowns.forEach(dropdown => {
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (selectedOption && selectedOption.value) {
                const gameNumber = this.extractGameNumber(dropdown);
                const teamName = this.cleanTeamName(selectedOption.text);
                if (gameNumber) {
                    teams.set(gameNumber, teamName);
                }
            }
        });

        return teams;
    },

    extractGameNumber(dropdown) {
        const match = dropdown.name?.match(/\d+/) || dropdown.id?.match(/\d+/);
        return match ? match[0] : null;
    },

    cleanTeamName(teamText) {
        return teamText
            .replace(/\([^)]*\)/g, '')
            .replace(/-?\d+\.?\d*/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    },

    getSpreadForTeam(teamName) {
        const spreadsData = storageUtils.get('currentSpreads', []);
        for (const game of spreadsData) {
            if (game.team1.includes(teamName)) return game.spread1;
            if (game.team2.includes(teamName)) return game.spread2;
        }
        return null;
    },

    addLockPanel() {
        const panel = uiUtils.createPanel({
            left: '20px',
            bottom: '20px',
            width: '250px'
        });

        panel.innerHTML = `
            <div class="psm-panel-header">
                <strong>Lock Status</strong>
            </div>
            <div class="psm-panel-content" id="lock-status-display">
                <div class="empty-state">No lock selected</div>
            </div>
        `;

        document.body.appendChild(panel);
    },

    updateLockDisplay() {
        const display = document.getElementById('lock-status-display');
        if (!display) return;

        const lockDropdown = this.getLockDropdown();
        if (!lockDropdown || !lockDropdown.value) {
            display.innerHTML = '<div class="empty-state">No lock selected</div>';
            return;
        }

        const selectedOption = lockDropdown.options[lockDropdown.selectedIndex];
        const teamName = this.cleanTeamName(selectedOption.text);
        const spread = this.getSpreadForTeam(teamName);

        display.innerHTML = `
            <div class="lock-status">
                <div style="font-size: 24px; text-align: center; margin-bottom: 10px;">ðŸ”’</div>
                <div style="font-weight: bold; margin-bottom: 5px;">
                    Game ${lockDropdown.value}
                </div>
                <div>${teamName}</div>
                ${spread ? `<div class="spread-info">Spread: ${spread}</div>` : ''}
            </div>
        `;
    }
};

window.lockModule = lockModule;

================
File: modules/lock-module.js
================
const lockModule = {
    async initialize() {
        if (!window.location.pathname.includes('fbpicks')) return;
        
        this.setupLockDropdown();
        this.addLockPanel();
    },

    setupLockDropdown() {
        const lockDropdown = this.getLockDropdown();
        if (!lockDropdown) return;

        // Style the lock dropdown
        lockDropdown.classList.add('psm-select');
        lockDropdown.style.border = '2px solid #28a745';

        // Add change listener to regular dropdowns
        const gameDropdowns = Array.from(document.querySelectorAll('select'))
            .filter(dropdown => !this.isLockDropdown(dropdown));

        gameDropdowns.forEach(dropdown => {
            dropdown.addEventListener('change', () => {
                this.updateLockDropdown();
            });
        });

        // Add change listener to lock dropdown
        lockDropdown.addEventListener('

================
File: modules/picks-history-module.js
================
// modules/picksHistoryModule.js
const picksHistoryModule = {
    async initialize() {
        this.addStyles();
        await this.createHistoryPanel();

        if (window.location.pathname.includes('fbpicks')) {
            await this.setupFormHandling();
        }
    },

    addStyles() {
        uiUtils.addStyles(`
            .picks-history-panel {
                max-width: 400px;
                max-height: 80vh;
                overflow: hidden;
            }

            .picks-history-content {
                overflow-y: auto;
                max-height: calc(80vh - 50px);
            }

            .week-selector {
                width: 100%;
                margin-bottom: 10px;
            }

            .pick-item {
                background: white;
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 8px;
                border-left: 3px solid transparent;
            }

            .pick-item.locked {
                border-left-color: #28a745;
            }

            .pick-item.winner {
                background-color: #d4edda;
            }

            .pick-item.loser {
                background-color: #f8d7da;
            }

            .pick-details {
                font-size: 0.9em;
                color: #6c757d;
                margin-top: 5px;
            }

            .picks-controls {
                display: flex;
                gap: 10px;
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid #dee2e6;
            }

            .picks-history-stats {
                background: #f8f9fa;
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 10px;
            }

            .stat-item {
                display: flex;
                justify-content: space-between;
                margin-bottom: 5px;
            }

            .export-options {
                display: none;
                margin-top: 10px;
            }

            .export-options.visible {
                display: block;
            }

            .export-option-btn {
                margin: 5px;
                padding: 5px 10px;
            }

            .history-empty-state {
                text-align: center;
                padding: 20px;
                color: #6c757d;
            }
        `);
    },

    async createHistoryPanel() {
        const panel = uiUtils.createPanel({
            right: '20px',
            top: '20px',
            width: '400px'
        });

        panel.className = 'picks-history-panel psm-panel';
        panel.innerHTML = `
            <div class="psm-panel-header">
                <strong>Picks History</strong>
                <button class="psm-button collapse-btn" style="padding: 2px 6px;">_</button>
            </div>
            <div class="psm-panel-content">
                <div class="picks-history-stats"></div>
                <select class="psm-select week-selector">
                    <option value="">Select Week</option>
                </select>
                <div class="picks-history-content"></div>
                <div class="picks-controls">
                    <button class="psm-button export-btn">Export</button>
                    <button class="psm-button clear-btn" style="background: #dc3545;">Clear History</button>
                </div>
                <div class="export-options">
                    <button class="psm-button export-option-btn" data-format="json">JSON</button>
                    <button class="psm-button export-option-btn" data-format="csv">CSV</button>
                </div>
            </div>
        `;

        document.body.appendChild(panel);

        this.setupPanelListeners(panel);
        await this.updateWeeksList();
        await this.updateStats();
    },

    async setupPanelListeners(panel) {
        const collapseBtn = panel.querySelector('.collapse-btn');
        const content = panel.querySelector('.psm-panel-content');
        collapseBtn.addEventListener('click', () => {
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
            collapseBtn.textContent = content.style.display === 'none' ? 'â–¡' : '_';
        });

        const weekSelector = panel.querySelector('.week-selector');
        weekSelector.addEventListener('change', () => {
            this.displayPicksForWeek(weekSelector.value);
        });

        const exportBtn = panel.querySelector('.export-btn');
        const exportOptions = panel.querySelector('.export-options');
        exportBtn.addEventListener('click', () => {
            exportOptions.classList.toggle('visible');
        });

        panel.querySelectorAll('.export-option-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.exportPicks(btn.dataset.format);
                exportOptions.classList.remove('visible');
            });
        });

        const clearBtn = panel.querySelector('.clear-btn');
        clearBtn.addEventListener('click', () => this.handleClearHistory());
    },

    async updateWeeksList() {
        const allPicks = await storageUtils.get('picksHistory', {});
        const weekSelector = document.querySelector('.week-selector');
        if (!weekSelector) return;

        while (weekSelector.options.length > 1) {
            weekSelector.remove(1);
        }

        Object.keys(allPicks)
            .sort((a, b) => parseInt(b) - parseInt(a))
            .forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                weekSelector.appendChild(option);
            });
    },

    async updateStats() {
        const stats = await this.calculateStats();
        const statsDiv = document.querySelector('.picks-history-stats');
        if (!statsDiv) return;

        statsDiv.innerHTML = `
            <div class="stat-item">
                <span>Total Picks:</span>
                <strong>${stats.totalPicks}</strong>
            </div>
            <div class="stat-item">
                <span>Weeks Played:</span>
                <strong>${stats.weeksPlayed}</strong>
            </div>
            <div class="stat-item">
                <span>Lock Success Rate:</span>
                <strong>${stats.lockSuccessRate}%</strong>
            </div>
        `;
    },

    async calculateStats() {
        const allPicks = await storageUtils.get('picksHistory', {});
        const stats = {
            totalPicks: 0,
            weeksPlayed: Object.keys(allPicks).length,
            locksWon: 0,
            totalLocks: 0
        };

        Object.values(allPicks).forEach(weekPicks => {
            weekPicks.forEach(pick => {
                stats.totalPicks += Object.keys(pick.selections).length;
                const lockedPick = Object.values(pick.selections).find(s => s.isLocked);
                if (lockedPick) {
                    stats.totalLocks++;
                    if (lockedPick.won) stats.locksWon++;
                }
            });
        });

        stats.lockSuccessRate = stats.totalLocks ?
            ((stats.locksWon / stats.totalLocks) * 100).toFixed(1) : 0;

        return stats;
    },

    async displayPicksForWeek(week) {
        const content = document.querySelector('.picks-history-content');
        if (!content || !week) return;

        const allPicks = await storageUtils.get('picksHistory', {});
        const weekPicks = allPicks[week] || [];

        if (weekPicks.length === 0) {
            content.innerHTML = `<div class="history-empty-state">No picks found for Week ${week}</div>`;
            return;
        }

        content.innerHTML = weekPicks
            .sort((a, b) => b.timestamp - a.timestamp)
            .map(picks => this.renderPickSet(picks, week))
            .join('');
    },

    renderPickSet(picks, week) {
        const timestamp = new Date(picks.timestamp).toLocaleString();
        const picksHtml = Object.entries(picks.selections)
            .map(([game, selection]) => `
                <div class="pick-item ${selection.isLocked ? 'locked' : ''} ${selection.won ? 'winner' : selection.won === false ? 'loser' : ''}">
                    <div>Game ${game}: ${selection.team}</div>
                    ${selection.isLocked ? '<span>ðŸ”’ Lock</span>' : ''}
                    ${selection.spread ? `<div>Spread: ${selection.spread}</div>` : ''}
                </div>
            `).join('');

        return `
            <div class="pick-set">
                <div class="pick-details">Submitted: ${timestamp}</div>
                ${picksHtml}
            </div>
        `;
    },

    async setupFormHandling() {
        const form = document.querySelector('form');
        if (!form) return;

        form.addEventListener('submit', async (e) => {
            const picks = this.gatherCurrentPicks();
            await this.storePicks(picks);
        });
    },

    gatherCurrentPicks() {
        const picks = {
            timestamp: Date.now(),
            week: this.determineCurrentWeek(),
            selections: {},
            source: 'Pigskin-Enhancement-Suite',
            version: '1.0.0'
        };

        document.querySelectorAll('select').forEach(dropdown => {
            if (this.isLockDropdown(dropdown)) return;

            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (selectedOption?.value) {
                picks.selections[dropdown.name] = {
                    team: this.cleanTeamName(selectedOption.text),
                    value: selectedOption.value,
                    isLocked: this.isTeamLocked(selectedOption.value),
                    spread: this.getSpread(selectedOption.text)
                };
            }
        });

        return picks;
    },

    async storePicks(picks) {
        const history = await storageUtils.get('picksHistory', {});
        if (!history[picks.week]) {
            history[picks.week] = [];
        }
        history[picks.week].push(picks);
        await storageUtils.set('picksHistory', history);
        await this.updateWeeksList();
        await this.updateStats();
    },

    async exportPicks(format) {
        const allPicks = await storageUtils.get('picksHistory', {});
        let exportData;
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `pigskin_picks_history_${timestamp}`;

        if (format === 'json') {
            exportData = JSON.stringify(allPicks, null, 2);
            this.downloadFile(exportData, `${filename}.json`, 'application/json');
        } else if (format === 'csv') {
            exportData = this.convertToCSV(allPicks);
            this.downloadFile(exportData, `${filename}.csv`, 'text/csv');
        }
    },

    downloadFile(content, filename, type) {
        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');

        a.href = url;
        a.download = filename;
        a.style.display = 'none';

        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    },

    convertToCSV(picksHistory) {
        const headers = [
            'Week',
            'Timestamp',
            'Game',
            'Team',
            'Locked',
            'Spread',
            'Result',
            'Source',
            'Version'
        ];

        const rows = [headers];

        Object.entries(picksHistory).forEach(([week, weekPicks]) => {
            weekPicks.forEach(pick => {
                Object.entries(pick.selections).forEach(([game, selection]) => {
                    rows.push([
                        week,
                        new Date(pick.timestamp).toISOString(),
                        game,
                        selection.team,
                        selection.isLocked ? 'Yes' : 'No',
                        selection.spread || '',
                        selection.won === true ? 'Won' :
                            selection.won === false ? 'Lost' : 'Unknown',
                        pick.source || 'Pigskin-Enhancement-Suite',
                        pick.version || '1.0.0'
                    ]);
                });
            });
        });

        return rows.map(row =>
            row.map(cell =>
                `"${String(cell).replace(/"/g, '""')}"`
            ).join(',')
        ).join('\n');
    },

    async handleClearHistory() {
        if (!confirm('Are you sure you want to clear all picks history? This cannot be undone.')) {
            return;
        }

        await storageUtils.set('picksHistory', {});
        await this.updateWeeksList();
        await this.updateStats();

        const content = document.querySelector('.picks-history-content');
        if (content) {
            content.innerHTML = '<div class="history-empty-state">No picks history</div>';
        }

        uiUtils.showNotification('Picks history cleared', 'success');
    },

    isLockDropdown(dropdown) {
        return dropdown.name?.toLowerCase().includes('lock') ||
            dropdown.id?.toLowerCase().includes('lock');
    },

    isTeamLocked(value) {
        const lockDropdown = Array.from(document.querySelectorAll('select'))
            .find(d => this.isLockDropdown(d));
        return lockDropdown && lockDropdown.value === value;
    },

    cleanTeamName(text) {
        return text
            .replace(/\([^)]*\)/g, '')
            .replace(/[-+]?\d+\.?\d*/g, '')
            .trim();
    },

    getSpread(text) {
        const match = text.match(/[-+]?\d+\.?\d*/);
        return match ? match[0] : null;
    },

    determineCurrentWeek() {
        const weekMatch = document.body.textContent.match(/Week (\d+)/i);
        return weekMatch ? weekMatch[1] : 'unknown';
    }
};

window.picksHistoryModule = picksHistoryModule;

================
File: modules/picks-module.js
================
const picksModule = {
    async initialize() {
        if (!window.location.pathname.includes('fbpicks')) return;
        
        this.setupPicksForm();
        await this.checkGameTimes();
        this.addPicksPanel();
    },

    setupPicksForm() {
        const form = document.querySelector('form');
        if (!form) return;

        // Intercept form submission
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Validate times
            const invalidGames = await this.checkGameTimes();
            if (invalidGames.length > 0) {
                this.showGameTimeWarning(invalidGames, form);
                return;
            }

            // Store picks before submission
            await this.storeCurrentPicks();
            form.submit();
        });

        // Add change listeners to dropdowns
        const dropdowns = document.querySelectorAll('select');
        dropdowns.forEach(dropdown => {
            if (!this.isLockDropdown(dropdown)) {
                dropdown.addEventListener('change', () => {
                    this.updatePicksDisplay();
                    window.lockModule?.updateLockDropdown();
                });
            }
        });
    },

    async checkGameTimes() {
        const spreadsData = await storageUtils.get('currentSpreads');
        if (!spreadsData) return [];

        const now = new Date();
        const invalidGames = [];

        document.querySelectorAll('select').forEach(dropdown => {
            if (this.isLockDropdown(dropdown)) return;

            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (!selectedOption?.value) return;

            const teamName = this.cleanTeamName(selectedOption.text);
            const gameData = spreadsData.find(game => 
                game.team1.includes(teamName) || 
                game.team2.includes(teamName)
            );

            if (gameData && new Date(gameData.time) < now) {
                invalidGames.push({
                    team1: gameData.team1,
                    team2: gameData.team2,
                    time: gameData.time
                });
            }
        });

        return invalidGames;
    },

    showGameTimeWarning(invalidGames, form) {
        const content = document.createElement('div');
        content.innerHTML = `
            <h3>Warning: Games Already Started</h3>
            <p>The following games have already begun:</p>
            <ul>
                ${invalidGames.map(game => `
                    <li>${game.team1} vs ${game.team2} - 
                    Started: ${new Date(game.time).toLocaleString()}</li>
                `).join('')}
            </ul>
            <p>Unless these games were cancelled, you cannot change picks for these games.</p>
        `;

        const buttons = document.createElement('div');
        buttons.style.marginTop = '15px';
        buttons.style.textAlign = 'right';

        const proceedBtn = uiUtils.createElement('button', {
            className: 'psm-button',
            text: 'Proceed Anyway',
            styles: { marginRight: '10px', background: '#dc3545' }
        });
        proceedBtn.onclick = () => {
            form.submit();
            modal.close();
        };

        const cancelBtn = uiUtils.createElement('button', {
            className: 'psm-button',
            text: 'Modify Picks',
            styles: { background: '#28a745' }
        });
        cancelBtn.onclick = () => modal.close();

        buttons.appendChild(proceedBtn);
        buttons.appendChild(cancelBtn);
        content.appendChild(buttons);

        const modal = uiUtils.createModal(content);
    },

    async storeCurrentPicks() {
        const picks = {
            timestamp: Date.now(),
            week: this.determineCurrentWeek(),
            selections: {}
        };

        document.querySelectorAll('select').forEach(dropdown => {
            if (this.isLockDropdown(dropdown)) return;

            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (selectedOption?.value) {
                picks.selections[dropdown.name] = {
                    team: this.cleanTeamName(selectedOption.text),
                    value: selectedOption.value,
                    isLocked: this.isTeamLocked(selectedOption.value)
                };
            }
        });

        await storageUtils.set('lastPicks', picks);
        await this.updatePicksHistory(picks);
    },

    async updatePicksHistory(picks) {
        const history = await storageUtils.get('picksHistory', {});
        if (!history[picks.week]) {
            history[picks.week] = [];
        }
        history[picks.week].push(picks);
        await storageUtils.set('picksHistory', history);
    },

    addPicksPanel() {
        const panel = uiUtils.createPanel({
            right: '20px',
            top: '20px'
        });

        panel.innerHTML = `
            <div class="psm-panel-header">
                <strong>Current Picks</strong>
            </div>
            <div class="psm-panel-content" id="current-picks-display">
                <div class="empty-state">Make selections to see them here</div>
            </div>
        `;

        document.body.appendChild(panel);
    },

    updatePicksDisplay() {
        const display = document.getElementById('current-picks-display');
        if (!display) return;

        const picks = {};
        let hasSelections = false;

        document.querySelectorAll('select').forEach(dropdown => {
            if (this.isLockDropdown(dropdown)) return;

            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (selectedOption?.value) {
                hasSelections = true;
                picks[dropdown.name] = {
                    team: this.cleanTeamName(selectedOption.text),
                    isLocked: this.isTeamLocked(selectedOption.value)
                };
            }
        });

        if (!hasSelections) {
            display.innerHTML = '<div class="empty-state">Make selections to see them here</div>';
            return;
        }

        display.innerHTML = Object.entries(picks).map(([game, pick]) => `
            <div class="pick-item ${pick.isLocked ? 'locked' : ''}">
                ${game}: ${pick.team} ${pick.isLocked ? 'ðŸ”’' : ''}
            </div>
        `).join('');
    },

    isLockDropdown(dropdown) {
        return dropdown.name?.toLowerCase().includes('lock') ||
               dropdown.id?.toLowerCase().includes('lock');
    },

    isTeamLocked(value) {
        const lockDropdown = Array.from(document.querySelectorAll('select'))
            .find(d => this.isLockDropdown(d));
        return lockDropdown && lockDropdown.value === value;
    },

    cleanTeamName(text) {
        return text
            .replace(/\([^)]*\)/g, '') // Remove spreads in parentheses
            .replace(/[-+]?\d+\.?\d*/g, '') // Remove remaining numbers
            .trim();
    },

    determineCurrentWeek() {
        const weekMatch = document.body.textContent.match(/Week (\d+)/i);
        return weekMatch ? weekMatch[1] : 'unknown';
    }
};

window.picksModule = picksModule;

================
File: modules/spreads-module.js
================
const spreadsModule = {
    async initialize() {
        if (window.location.pathname.includes('spreads')) {
            await this.setupSpreadsPage();
        } else if (window.location.pathname.includes('fbpicks')) {
            await this.applySpreadsToPicksPage();
        }
    },

    async setupSpreadsPage() {
        const spreadsData = await this.collectSpreadsData();
        await storageUtils.set('currentSpreads', spreadsData);
        this.addTimeZoneButtons();
        this.highlightUserPicks();
    },

    async collectSpreadsData() {
        const spreads = [];
        const rows = document.querySelectorAll('table tr');
        let currentGame = {};

        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 3) {
                const teamText = cells[0]?.textContent?.trim();
                const spreadText = cells[1]?.textContent?.trim();
                const timeText = cells[2]?.textContent?.trim();

                if (teamText && spreadText) {
                    if (!currentGame.team1) {
                        currentGame = {
                            team1: teamText,
                            spread1: this.parseSpread(spreadText),
                            time: this.parseGameTime(timeText)
                        };
                    } else {
                        currentGame.team2 = teamText;
                        currentGame.spread2 = this.parseSpread(spreadText);
                        spreads.push({...currentGame});
                        currentGame = {};
                    }
                }
            }
        });

        return spreads;
    },

    parseSpread(text) {
        const match = text.match(/-?\d+\.?\d*/);
        return match ? parseFloat(match[0]) : 0;
    },

    parseGameTime(text) {
        // Convert time text to standardized format
        try {
            const timeMatch = text.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
            if (timeMatch) {
                const [_, hours, minutes, period] = timeMatch;
                const date = new Date();
                let hour = parseInt(hours);
                
                if (period) {
                    if (period.toUpperCase() === 'PM' && hour < 12) hour += 12;
                    if (period.toUpperCase() === 'AM' && hour === 12) hour = 0;
                }
                
                date.setHours(hour, parseInt(minutes), 0, 0);
                return date.toISOString();
            }
        } catch (error) {
            console.error('Time parsing error:', error);
        }
        return null;
    },

    addTimeZoneButtons() {
        const timeZones = [
            { label: 'ET', zone: 'America/New_York' },
            { label: 'CT', zone: 'America/Chicago' },
            { label: 'MT', zone: 'America/Denver' },
            { label: 'AZ', zone: 'America/Phoenix' },
            { label: 'PT', zone: 'America/Los_Angeles' }
        ];

        const buttonContainer = uiUtils.createElement('div', {
            className: 'psm-panel',
            styles: {
                top: '20px',
                right: '20px',
                display: 'flex',
                gap: '5px',
                padding: '10px'
            }
        });

        timeZones.forEach(({label, zone}) => {
            const button = uiUtils.createElement('button', {
                className: 'psm-button',
                text: label,
                attributes: {
                    'data-zone': zone
                }
            });

            button.addEventListener('click', () => this.convertTimesToZone(zone));
            buttonContainer.appendChild(button);
        });

        document.body.appendChild(buttonContainer);
    },

    convertTimesToZone(targetZone) {
        const timeCells = document.querySelectorAll('td:nth-child(3)');
        timeCells.forEach(cell => {
            const originalTime = cell.getAttribute('data-original-time') || cell.textContent;
            if (!cell.getAttribute('data-original-time')) {
                cell.setAttribute('data-original-time', originalTime);
            }

            try {
                const date = new Date(this.parseGameTime(originalTime));
                const converted = date.toLocaleTimeString('en-US', {
                    timeZone: targetZone,
                    hour: 'numeric',
                    minute: '2-digit'
                });
                cell.textContent = `${converted} ${targetZone.split('/')[1]}`;
            } catch (error) {
                console.error('Time conversion error:', error);
            }
        });
    },

    async highlightUserPicks() {
        const lastPicks = await storageUtils.get('lastPicks');
        if (!lastPicks) return;

        const teamCells = document.querySelectorAll('td:first-child');
        teamCells.forEach(cell => {
            const teamName = cell.textContent.trim();
            if (Object.values(lastPicks.selections).some(pick => 
                pick.team.includes(teamName)
            )) {
                cell.style.backgroundColor = '#e6ffe6';
                cell.style.borderLeft = '3px solid #00cc00';
            }
        });
    },

    async applySpreadsToPicksPage() {
        const spreadsData = await storageUtils.get('currentSpreads');
        if (!spreadsData) {
            uiUtils.showNotification('Please visit spreads page first to load current spreads', 'warning');
            return;
        }

        this.updatePicksDropdowns(spreadsData);
    },

    updatePicksDropdowns(spreadsData) {
        const dropdowns = document.querySelectorAll('select');
        dropdowns.forEach(dropdown => {
            if (dropdown.name?.toLowerCase().includes('lock')) return;

            Array.from(dropdown.options).forEach(option => {
                if (!option.value) return;

                const teamName = option.text.trim();
                const gameData = this.findTeamInSpreads(teamName, spreadsData);
                
                if (gameData) {
                    const spread = this.getTeamSpread(teamName, gameData);
                    const spreadDisplay = spread > 0 ? `+${spread}` : spread;
                    option.text = `${teamName} (${spreadDisplay})`;
                }
            });
        });
    },

    findTeamInSpreads(teamName, spreadsData) {
        return spreadsData.find(game => 
            game.team1.includes(teamName) || 
            game.team2.includes(teamName)
        );
    },

    getTeamSpread(teamName, gameData) {
        if (gameData.team1.includes(teamName)) return gameData.spread1;
        if (gameData.team2.includes(teamName)) return gameData.spread2;
        return 0;
    }
};

window['spreads-module'] = spreadsModule;

================
File: modules/standings-module.js
================
const standingsModule = {
    async initialize() {
        if (!window.location.pathname.includes('standings')) return;
        
        this.addStyles();
        await this.setupBookmarks();
        this.addBookmarkControls();
    },

    addStyles() {
        uiUtils.addStyles(`
            .standings-controls {
                position: fixed;
                top: 20px;
                right: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 1000;
                min-width: 250px;
                max-width: 300px;
            }

            .bookmarked-player {
                background-color: #fff3cd !important;
                transition: background-color 0.3s;
            }

            .bookmark-btn {
                padding: 2px 6px;
                margin-left: 5px;
                font-size: 0.8em;
                cursor: pointer;
                border: none;
                border-radius: 3px;
                background: #f8f9fa;
            }

            .bookmark-btn.active {
                background: #ffc107;
                color: #000;
            }

            .bookmark-list {
                margin-top: 10px;
                max-height: 300px;
                overflow-y: auto;
            }

            .bookmark-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px;
                margin: 5px 0;
                background: #f8f9fa;
                border-radius: 4px;
                font-size: 0.9em;
            }

            .bookmark-item:hover {
                background: #e9ecef;
            }

            .bookmark-item-controls {
                display: flex;
                gap: 5px;
            }

            .jump-btn {
                background: #007bff;
                color: white;
                border: none;
                padding: 3px 8px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 0.8em;
            }

            .remove-bookmark {
                background: #dc3545;
                color: white;
                border: none;
                padding: 3px 8px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 0.8em;
            }

            .flash-highlight {
                animation: flashHighlight 1s;
            }

            @keyframes flashHighlight {
                0% { background-color: #ffc107; }
                100% { background-color: #fff3cd; }
            }

            .search-box {
                width: 100%;
                padding: 5px;
                margin-bottom: 10px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
            }
        `);
    },

    async setupBookmarks() {
        // Add bookmark buttons to each player
        const playerRows = document.querySelectorAll('tr');
        playerRows.forEach(row => {
            const nameCell = row.querySelector('td:first-child');
            if (nameCell && nameCell.textContent.trim()) {
                const bookmarkBtn = document.createElement('button');
                bookmarkBtn.className = 'bookmark-btn';
                bookmarkBtn.innerHTML = 'â˜…';
                bookmarkBtn.title = 'Bookmark this player';
                
                bookmarkBtn.addEventListener('click', () => this.toggleBookmark(row));
                
                nameCell.appendChild(bookmarkBtn);
            }
        });

        // Highlight existing bookmarks
        await this.highlightBookmarkedPlayers();
    },

    async toggleBookmark(row) {
        const playerName = row.querySelector('td:first-child').textContent.trim().replace('â˜…', '');
        const bookmarks = await storageUtils.get('playerBookmarks', []);
        
        const index = bookmarks.indexOf(playerName);
        if (index === -1) {
            bookmarks.push(playerName);
            uiUtils.showNotification(`Bookmarked: ${playerName}`, 'success');
        } else {
            bookmarks.splice(index, 1);
            uiUtils.showNotification(`Removed bookmark: ${playerName}`, 'info');
        }
        
        await storageUtils.set('playerBookmarks', bookmarks);
        await this.updateBookmarkList();
        await this.highlightBookmarkedPlayers();
    },

    addBookmarkControls() {
        const controls = document.createElement('div');
        controls.className = 'standings-controls';
        
        controls.innerHTML = `
            <div class="psm-panel-header">
                <strong>Bookmarked Players</strong>
                <button class="psm-button collapse-btn">_</button>
            </div>
            <div class="controls-content">
                <input type="text" class="search-box" placeholder="Search players...">
                <div class="bookmark-list"></div>
            </div>
        `;

        document.body.appendChild(controls);

        // Setup event listeners
        const searchBox = controls.querySelector('.search-box');
        searchBox.addEventListener('input', (e) => this.filterPlayers(e.target.value));

        const collapseBtn = controls.querySelector('.collapse-btn');
        const content = controls.querySelector('.controls-content');
        collapseBtn.addEventListener('click', () => {
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
            collapseBtn.textContent = content.style.display === 'none' ? 'â–¡' : '_';
        });

        // Initial bookmark list
        this.updateBookmarkList();
    },

    async updateBookmarkList() {
        const bookmarkList = document.querySelector('.bookmark-list');
        const bookmarks = await storageUtils.get('playerBookmarks', []);

        if (bookmarks.length === 0) {
            bookmarkList.innerHTML = '<div class="bookmark-item">No bookmarked players</div>';
            return;
        }

        bookmarkList.innerHTML = bookmarks.map(player => `
            <div class="bookmark-item">
                <span>${player}</span>
                <div class="bookmark-item-controls">
                    <button class="jump-btn" data-player="${player}">Jump</button>
                    <button class="remove-bookmark" data-player="${player}">âœ•</button>
                </div>
            </div>
        `).join('');

        // Add event listeners to buttons
        bookmarkList.querySelectorAll('.jump-btn').forEach(btn => {
            btn.addEventListener('click', () => this.jumpToPlayer(btn.dataset.player));
        });

        bookmarkList.querySelectorAll('.remove-bookmark').forEach(btn => {
            btn.addEventListener('click', async () => {
                const player = btn.dataset.player;
                const bookmarks = await storageUtils.get('playerBookmarks', []);
                const updatedBookmarks = bookmarks.filter(p => p !== player);
                await storageUtils.set('playerBookmarks', updatedBookmarks);
                await this.updateBookmarkList();
                await this.highlightBookmarkedPlayers();
                uiUtils.showNotification(`Removed bookmark: ${player}`, 'info');
            });
        });
    },

    async highlightBookmarkedPlayers() {
        const bookmarks = await storageUtils.get('playerBookmarks', []);
        
        // Remove existing highlights
        document.querySelectorAll('.bookmarked-player').forEach(el => {
            el.classList.remove('bookmarked-player');
        });

        // Add new highlights
        document.querySelectorAll('tr').forEach(row => {
            const nameCell = row.querySelector('td:first-child');
            if (nameCell) {
                const playerName = nameCell.textContent.trim().replace('â˜…', '');
                if (bookmarks.includes(playerName)) {
                    row.classList.add('bookmarked-player');
                    const bookmarkBtn = nameCell.querySelector('.bookmark-btn');
                    if (bookmarkBtn) {
                        bookmarkBtn.classList.add('active');
                    }
                }
            }
        });
    },

    jumpToPlayer(playerName) {
        const rows = document.querySelectorAll('tr');
        for (const row of rows) {
            const nameCell = row.querySelector('td:first-child');
            if (nameCell && nameCell.textContent.trim().replace('â˜…', '').includes(playerName)) {
                // Smooth scroll to player
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Flash effect
                row.classList.remove('flash-highlight');
                void row.offsetWidth; // Trigger reflow
                row.classList.add('flash-highlight');
                break;
            }
        }
    },

    filterPlayers(searchTerm) {
        if (!searchTerm) {
            this.highlightBookmarkedPlayers();
            return;
        }

        const searchLower = searchTerm.toLowerCase();
        document.querySelectorAll('tr').forEach(row => {
            const nameCell = row.querySelector('td:first-child');
            if (nameCell) {
                const playerName = nameCell.textContent.trim().replace('â˜…', '');
                if (playerName.toLowerCase().includes(searchLower)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            }
        });
    }
};

window.standingsModule = standingsModule;

================
File: modules/time-module.js
================
const timeModule = {
    timeZones: [
        { label: 'ET', zone: 'America/New_York' },
        { label: 'CT', zone: 'America/Chicago' },
        { label: 'MT', zone: 'America/Denver' },
        { label: 'AZ', zone: 'America/Phoenix' },
        { label: 'PT', zone: 'America/Los_Angeles' },
        { label: 'Local', zone: Intl.DateTimeFormat().resolvedOptions().timeZone }
    ],

    async initialize() {
        this.addStyles();
        
        if (window.location.pathname.includes('spreads')) {
            this.setupSpreadsPageTime();
        } else if (window.location.pathname.includes('fbpicks')) {
            await this.setupPicksPageTime();
        }
    },

    addStyles() {
        uiUtils.addStyles(`
            .time-panel {
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 1001;
                padding: 10px;
                margin-bottom: 10px;
            }

            .time-zone-buttons {
                display: flex;
                gap: 5px;
                flex-wrap: wrap;
                margin-bottom: 10px;
            }

            .time-zone-btn {
                padding: 5px 10px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                cursor: pointer;
                background: #f8f9fa;
                transition: all 0.2s;
            }

            .time-zone-btn.active {
                background: #007bff;
                color: white;
                border-color: #0056b3;
            }

            .time-zone-btn:hover {
                background: #e9ecef;
            }

            .time-zone-btn.active:hover {
                background: #0056b3;
            }

            .game-time {
                transition: background-color 0.3s;
            }

            .game-time.updated {
                background-color: #fff3cd;
            }

            .game-time-warning {
                color: #dc3545;
                font-weight: bold;
            }

            .countdown-timer {
                font-size: 0.9em;
                color: #6c757d;
                margin-top: 5px;
            }
        `);
    },

    setupSpreadsPageTime() {
        // Create time zone panel
        const panel = uiUtils.createElement('div', {
            className: 'psm-panel',
            styles: {
                top: '20px',
                right: '20px'
            }
        });

        panel.innerHTML = `
            <div class="psm-panel-header">
                <strong>Time Zones</strong>
            </div>
            <div class="psm-panel-content">
                <div class="time-zone-buttons"></div>
                <div id="current-time-display"></div>
            </div>
        `;

        // Add time zone buttons
        const buttonContainer = panel.querySelector('.time-zone-buttons');
        this.timeZones.forEach(({label, zone}) => {
            const button = uiUtils.createElement('button', {
                className: 'time-zone-btn',
                text: label,
                attributes: {
                    'data-zone': zone
                }
            });

            button.addEventListener('click', (e) => {
                this.updateActiveTimeZone(e.target);
                this.convertPageTimes(zone);
            });

            buttonContainer.appendChild(button);
        });

        document.body.appendChild(panel);

        // Start current time display
        this.updateCurrentTimeDisplay();
        setInterval(() => this.updateCurrentTimeDisplay(), 1000);

        // Store original times
        this.storeOriginalTimes();
    },

    async setupPicksPageTime() {
        const spreadsData = await storageUtils.get('currentSpreads');
        if (!spreadsData) return;

        this.addGameTimeIndicators(spreadsData);
        this.startGameCountdowns();
    },

    storeOriginalTimes() {
        const timeCells = document.querySelectorAll('td:nth-child(3)');
        timeCells.forEach(cell => {
            const originalTime = cell.textContent.trim();
            cell.setAttribute('data-original-time', originalTime);
            cell.classList.add('game-time');
        });
    },

    updateActiveTimeZone(clickedButton) {
        document.querySelectorAll('.time-zone-btn').forEach(btn => 
            btn.classList.remove('active')
        );
        clickedButton.classList.add('active');
    },

    convertPageTimes(targetZone) {
        const timeCells = document.querySelectorAll('.game-time');
        timeCells.forEach(cell => {
            const originalTime = cell.getAttribute('data-original-time');
            if (!originalTime) return;

            try {
                const date = this.parseGameTime(originalTime);
                if (!date) return;

                const converted = date.toLocaleTimeString('en-US', {
                    timeZone: targetZone,
                    hour: 'numeric',
                    minute: '2-digit'
                });

                cell.textContent = `${converted} ${this.getTimeZoneAbbr(targetZone)}`;
                
                // Flash effect for updated time
                cell.classList.add('updated');
                setTimeout(() => cell.classList.remove('updated'), 1000);
            } catch (error) {
                console.error('Time conversion error:', error);
            }
        });
    },

    parseGameTime(timeString) {
        const today = new Date();
        const [time, period] = timeString.split(/\s+/);
        const [hours, minutes] = time.split(':').map(Number);

        let hour = hours;
        if (period) {
            if (period.toUpperCase() === 'PM' && hours < 12) hour += 12;
            if (period.toUpperCase() === 'AM' && hours === 12) hour = 0;
        }

        today.setHours(hour, minutes || 0, 0, 0);
        return today;
    },

    getTimeZoneAbbr(zone) {
        const tz = this.timeZones.find(t => t.zone === zone);
        return tz ? tz.label : zone.split('/').pop();
    },

    updateCurrentTimeDisplay() {
        const display = document.getElementById('current-time-display');
        if (!display) return;

        const activeZone = document.querySelector('.time-zone-btn.active')?.dataset.zone || 
                          Intl.DateTimeFormat().resolvedOptions().timeZone;

        const now = new Date().toLocaleTimeString('en-US', {
            timeZone: activeZone,
            hour: 'numeric',
            minute: '2-digit',
            second: '2-digit'
        });

        display.textContent = `Current Time: ${now} ${this.getTimeZoneAbbr(activeZone)}`;
    },

    addGameTimeIndicators(spreadsData) {
        const dropdowns = document.querySelectorAll('select');
        dropdowns.forEach(dropdown => {
            if (this.isLockDropdown(dropdown)) return;

            const gameNumber = this.extractGameNumber(dropdown);
            if (!gameNumber) return;

            const gameData = spreadsData.find(game => 
                game.team1.includes(this.getSelectedTeam(dropdown)) ||
                game.team2.includes(this.getSelectedTeam(dropdown))
            );

            if (gameData) {
                this.addTimeIndicator(dropdown, gameData);
            }
        });
    },

    addTimeIndicator(dropdown, gameData) {
        const container = document.createElement('div');
        container.className = 'countdown-timer';
        dropdown.parentNode.appendChild(container);

        this.updateTimeIndicator(container, gameData.time);
        setInterval(() => this.updateTimeIndicator(container, gameData.time), 1000);
    },

    updateTimeIndicator(container, gameTime) {
        const now = new Date();
        const gameDate = new Date(gameTime);
        const timeDiff = gameDate - now;

        if (timeDiff < 0) {
            container.innerHTML = `
                <div class="game-time-warning">
                    Game has started
                </div>
            `;
            return;
        }

        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

        container.textContent = `Time until game: ${hours}h ${minutes}m ${seconds}s`;
    },

    startGameCountdowns() {
        const countdowns = document.querySelectorAll('.countdown-timer');
        countdowns.forEach(countdown => {
            const updateInterval = setInterval(() => {
                if (countdown.querySelector('.game-time-warning')) {
                    clearInterval(updateInterval);
                }
            }, 1000);
        });
    },

    isLockDropdown(dropdown) {
        return dropdown.name?.toLowerCase().includes('lock') ||
               dropdown.id?.toLowerCase().includes('lock');
    },

    extractGameNumber(dropdown) {
        const match = dropdown.name?.match(/\d+/) || dropdown.id?.match(/\d+/);
        return match ? match[0] : null;
    },

    getSelectedTeam(dropdown) {
        const option = dropdown.options[dropdown.selectedIndex];
        return option ? option.text.trim().replace(/\([^)]*\)/g, '').trim() : '';
    }
};

window.timeModule = timeModule;

================
File: modules/user-id-module.js
================
const userIdModule = {
    async initialize() {
        this.addStyles();
        await this.createIdManager();
        
        if (window.location.pathname.includes('fbpicks')) {
            await this.setupFormAutoFill();
            await this.setupSaveReminder();
        }
    },

    addStyles() {
        uiUtils.addStyles(`
            .userid-panel {
                min-width: 250px;
            }

            .userid-input-group {
                display: flex;
                gap: 10px;
                margin-bottom: 10px;
            }

            .userid-history {
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid #dee2e6;
            }

            .userid-history-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 5px;
                margin: 2px 0;
                border-radius: 4px;
                background: #f8f9fa;
                font-size: 0.9em;
            }

            .userid-history-item:hover {
                background: #e9ecef;
            }

            .userid-status {
                font-size: 0.9em;
                margin-top: 5px;
                padding: 5px;
                border-radius: 4px;
            }

            .userid-status.success {
                background: #d4edda;
                color: #155724;
            }

            .userid-status.warning {
                background: #fff3cd;
                color: #856404;
            }

            .save-reminder-modal {
                text-align: center;
                padding: 20px;
            }

            .save-reminder-buttons {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 15px;
            }

            .userid-switch-container {
                display: flex;
                align-items: center;
                margin-top: 10px;
            }

            .userid-remember {
                margin-left: 10px;
                font-size: 0.9em;
            }
        `);
    },

    async createIdManager() {
        const panel = uiUtils.createPanel({
            top: '20px',
            left: '20px'
        });

        panel.className = 'userid-panel psm-panel';
        
        const savedId = await storageUtils.get('userId', '');
        const recentIds = await storageUtils.get('recentUserIds', []);
        
        panel.innerHTML = `
            <div class="psm-panel-header">
                <strong>User ID Manager</strong>
                <button class="psm-button collapse-btn" style="padding: 2px 6px;">_</button>
            </div>
            <div class="psm-panel-content">
                <div class="userid-input-group">
                    <input type="text" class="psm-input userid-input" 
                           placeholder="Enter your User ID" 
                           value="${savedId}">
                    <button class="psm-button save-btn" ${savedId ? 'disabled' : ''}>Save</button>
                </div>
                <div class="userid-status ${savedId ? 'success' : 'warning'}">
                    ${savedId ? 'ID Saved: ' + savedId : 'No ID saved'}
                </div>
                <div class="userid-switch-container">
                    <label class="userid-remember">
                        <input type="checkbox" ${await this.getAutoFillSetting() ? 'checked' : ''}>
                        Auto-fill ID on page load
                    </label>
                </div>
                ${this.renderRecentIds(recentIds)}
            </div>
        `;

        document.body.appendChild(panel);

        // Setup event listeners
        this.setupPanelListeners(panel);
    },

    renderRecentIds(recentIds) {
        if (!recentIds?.length) return '';

        return `
            <div class="userid-history">
                <strong>Recent IDs:</strong>
                ${recentIds.map(id => `
                    <div class="userid-history-item">
                        <span>${id}</span>
                        <button class="psm-button" data-id="${id}">Use</button>
                    </div>
                `).join('')}
            </div>
        `;
    },

    setupPanelListeners(panel) {
        // Collapse functionality
        const collapseBtn = panel.querySelector('.collapse-btn');
        const content = panel.querySelector('.psm-panel-content');
        collapseBtn.addEventListener('click', () => {
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
            collapseBtn.textContent = content.style.display === 'none' ? 'â–¡' : '_';
        });

        // Input and save button
        const input = panel.querySelector('.userid-input');
        const saveBtn = panel.querySelector('.save-btn');
        const status = panel.querySelector('.userid-status');

        input.addEventListener('input', () => {
            const newId = input.value.trim();
            saveBtn.disabled = !newId;
        });

        saveBtn.addEventListener('click', async () => {
            const newId = input.value.trim();
            if (newId) {
                await this.saveUserId(newId);
                saveBtn.disabled = true;
                status.className = 'userid-status success';
                status.textContent = 'ID Saved: ' + newId;
                await this.updateRecentIds(newId);
                await this.refreshRecentIdsList(panel);
            }
        });

        // Auto-fill checkbox
        const checkbox = panel.querySelector('input[type="checkbox"]');
        checkbox.addEventListener('change', () => {
            this.setAutoFillSetting(checkbox.checked);
        });

        // Recent IDs buttons
        panel.querySelectorAll('.userid-history-item button').forEach(button => {
            button.addEventListener('click', async () => {
                const id = button.dataset.id;
                input.value = id;
                await this.saveUserId(id);
                status.className = 'userid-status success';
                status.textContent = 'ID Saved: ' + id;
                
                // Update form if on picks page
                const formInput = document.querySelector('input[name="id"]');
                if (formInput) {
                    formInput.value = id;
                }
            });
        });
    },

    async saveUserId(id) {
        await storageUtils.set('userId', id);
        await this.updateRecentIds(id);
    },

    async updateRecentIds(newId) {
        const recentIds = await storageUtils.get('recentUserIds', []);
        const updatedIds = [
            newId,
            ...recentIds.filter(id => id !== newId)
        ].slice(0, 5); // Keep only last 5 IDs
        await storageUtils.set('recentUserIds', updatedIds);
    },

    async refreshRecentIdsList(panel) {
        const recentIds = await storageUtils.get('recentUserIds', []);
        const historyContainer = panel.querySelector('.userid-history');
        if (historyContainer) {
            historyContainer.innerHTML = this.renderRecentIds(recentIds);
            this.setupPanelListeners(panel); // Reattach event listeners
        }
    },

    async setupFormAutoFill() {
        if (!await this.getAutoFillSetting()) return;

        const savedId = await storageUtils.get('userId', '');
        if (!savedId) return;

        const idInput = document.querySelector('input[name="id"]');
        if (idInput) {
            idInput.value = savedId;
        }
    },

    async setupSaveReminder() {
        const form = document.querySelector('form');
        if (!form) return;

        form.addEventListener('submit', async (e) => {
            const savedId = await storageUtils.get('userId', '');
            const formId = document.querySelector('input[name="id"]')?.value;

            if (formId && formId !== savedId) {
                e.preventDefault();
                this.showSaveReminder(formId, form);
            }
        });
    },

    showSaveReminder(newId, form) {
        const content = document.createElement('div');
        content.className = 'save-reminder-modal';
        content.innerHTML = `
            <h3>Save New ID?</h3>
            <p>Would you like to save "${newId}" as your default ID?</p>
            <div class="save-reminder-buttons">
                <button class="psm-button save">Save & Submit</button>
                <button class="psm-button skip" style="background: #6c757d;">Just Submit</button>
            </div>
        `;

        const modal = uiUtils.createModal(content);

        // Handle save and submit
        content.querySelector('.save').addEventListener('click', async () => {
            await this.saveUserId(newId);
            modal.close();
            form.submit();
        });

        // Handle skip and submit
        content.querySelector('.skip').addEventListener('click', () => {
            modal.close();
            form.submit();
        });
    },

    async getAutoFillSetting() {
        return await storageUtils.get('autoFillUserId', true);
    },

    async setAutoFillSetting(value) {
        await storageUtils.set('autoFillUserId', value);
    }
};

window.userIdModule = userIdModule;

================
File: modules/wiki-team-module.js
================
// modules/wikiTeamModule.js
const wikiTeamModule = {
    async initialize() {
        this.teamAliases = null;
        this.config = {
            version: '1.0.0',
            wikiPage: 'List_of_current_National_Football_League_team_names',
            cacheKey: 'pses_team_aliases',
            cacheExpiry: 24 * 60 * 60 * 1000, // 24 hours
            updateCheckInterval: 12 * 60 * 60 * 1000 // 12 hours
        };

        try {
            await this.initializeTeamData();

            if (window.location.pathname.includes('spreads')) {
                await this.standardizeTeamNames();
            } else if (window.location.pathname.includes('fbpicks')) {
                await this.standardizePicksDropdowns();
            }
        } catch (error) {
            console.error('Wiki Team Module initialization error:', error);
            uiUtils.showNotification('Error loading team data', 'error');
        }
    },

    async initializeTeamData() {
        const cached = await this.getCache();
        if (cached) {
            this.teamAliases = cached;
            // Check for updates in background
            this.checkForUpdates();
        } else {
            await this.fetchAndCacheTeamNames();
        }
    },

    async getCache() {
        const cache = await storageUtils.get(this.config.cacheKey);
        if (!cache) return null;

        const { data, timestamp, version } = cache;
        const expired = Date.now() - timestamp > this.config.cacheExpiry;
        const outdated = version !== this.config.version;

        if (expired || outdated) {
            await storageUtils.set(this.config.cacheKey, null);
            return null;
        }

        return data;
    },

    async checkForUpdates() {
        try {
            const response = await this.makeWikiRequest();
            const newData = this.parseWikiResponse(response);
            const currentData = JSON.stringify(this.teamAliases);
            const newDataString = JSON.stringify(newData);

            if (currentData !== newDataString) {
                this.teamAliases = newData;
                await this.cacheTeamData(newData);
                uiUtils.showNotification('Team data updated', 'info');
            }
        } catch (error) {
            console.error('Update check failed:', error);
        }
    },

    async fetchAndCacheTeamNames() {
        const response = await this.makeWikiRequest();
        this.teamAliases = this.parseWikiResponse(response);
        await this.cacheTeamData(this.teamAliases);
    },

    async cacheTeamData(data) {
        await storageUtils.set(this.config.cacheKey, {
            data,
            timestamp: Date.now(),
            version: this.config.version
        });
    },

    makeWikiRequest() {
        return new Promise((resolve, reject) => {
            GM.xmlHttpRequest({
                method: 'GET',
                url: `https://en.wikipedia.org/w/api.php?action=parse&format=json&page=${this.config.wikiPage}&prop=text&origin=*`,
                headers: {
                    'Content-Type': 'application/json',
                    'x-source': 'Pigskin-Enhancement-Suite',
                    'x-version': this.config.version
                },
                onload: (response) => {
                    try {
                        const data = JSON.parse(response.responseText);
                        if (data.error) {
                            reject(new Error(data.error.info));
                            return;
                        }
                        resolve(data);
                    } catch (e) {
                        reject(e);
                    }
                },
                onerror: reject,
                ontimeout: () => reject(new Error('Request timed out'))
            });
        });
    },

    parseWikiResponse(response) {
        const teams = new Map();

        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(response.parse.text['*'], 'text/html');

            const tables = doc.querySelectorAll('table.wikitable');
            tables.forEach(table => {
                table.querySelectorAll('tr').forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                        const teamName = cells[0]?.textContent?.trim();
                        const alternateNames = cells[1]?.textContent?.trim();

                        if (teamName && alternateNames) {
                            // Create array of all possible names
                            const allNames = [
                                teamName,
                                ...alternateNames.split(',').map(n => n.trim()),
                                teamName.split(' ').pop(), // Last word (e.g., "Cowboys" from "Dallas Cowboys")
                                ...this.generateVariants(teamName) // Generate common variants
                            ];

                            // Store unique names only
                            const uniqueNames = [...new Set(allNames)];

                            teams.set(teamName, {
                                official: teamName,
                                aliases: uniqueNames.map(this.normalizeTeamName),
                                lastUpdated: Date.now()
                            });
                        }
                    }
                });
            });
        } catch (error) {
            console.error('Error parsing team data:', error);
            throw new Error('Failed to parse team data from Wikipedia');
        }

        return teams;
    },

    generateVariants(teamName) {
        const variants = [];
        const parts = teamName.split(' ');

        // City/Location only
        if (parts.length > 1) {
            variants.push(parts.slice(0, -1).join(' '));
        }

        // Common abbreviations (add more as needed)
        const commonAbbreviations = {
            'New York': 'NY',
            'San Francisco': 'SF',
            'Los Angeles': 'LA',
            'New England': 'NE'
        };

        for (const [full, abbr] of Object.entries(commonAbbreviations)) {
            if (teamName.includes(full)) {
                variants.push(teamName.replace(full, abbr));
            }
        }

        return variants;
    },

    normalizeTeamName(name) {
        return name.toLowerCase()
            .replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric
            .replace(/^the/, '') // Remove leading "the"
            .trim();
    },

    findTeamMatch(inputName) {
        if (!this.teamAliases) return inputName;

        const normalizedInput = this.normalizeTeamName(inputName);

        for (const [official, data] of this.teamAliases) {
            if (data.aliases.includes(normalizedInput)) {
                return official;
            }
        }

        // If no exact match, try partial matching
        for (const [official, data] of this.teamAliases) {
            if (data.aliases.some(alias => alias.includes(normalizedInput) ||
                normalizedInput.includes(alias))) {
                return official;
            }
        }

        return inputName;
    },

    async standardizeTeamNames() {
        if (!this.teamAliases) {
            await this.initializeTeamData();
        }

        const teamCells = document.querySelectorAll('td:first-child');
        let updated = 0;

        teamCells.forEach(cell => {
            const originalText = cell.textContent;
            const teamName = this.extractTeamName(originalText);
            const matchedName = this.findTeamMatch(teamName);

            if (matchedName !== teamName) {
                cell.textContent = originalText.replace(teamName, matchedName);
                cell.title = `Original: ${teamName}`;
                updated++;
            }
        });

        if (updated > 0) {
            uiUtils.showNotification(`Standardized ${updated} team names`, 'success');
        }
    },

    async standardizePicksDropdowns() {
        if (!this.teamAliases) {
            await this.initializeTeamData();
        }

        const dropdowns = document.querySelectorAll('select');
        let updated = 0;

        dropdowns.forEach(dropdown => {
            Array.from(dropdown.options).forEach(option => {
                if (!option.value) return;

                const originalText = option.text;
                const teamName = this.extractTeamName(originalText);
                const matchedName = this.findTeamMatch(teamName);

                if (matchedName !== teamName) {
                    option.text = originalText.replace(teamName, matchedName);
                    option.title = `Original: ${teamName}`;
                    updated++;
                }
            });
        });

        if (updated > 0) {
            uiUtils.showNotification(`Standardized ${updated} team names in dropdowns`, 'success');
        }
    },

    extractTeamName(text) {
        return text
            .replace(/\([^)]*\)/g, '') // Remove parentheses and contents
            .replace(/[-+]?\d+\.?\d*/g, '') // Remove numbers and decimals
            .replace(/\s+/g, ' ') // Normalize spaces
            .trim();
    },

    // Utility method for other modules
    getOfficialName(teamName) {
        return this.findTeamMatch(teamName);
    },

    // Debug method
    async diagnostics() {
        return {
            version: this.config.version,
            cacheStatus: await this.getCache() ? 'valid' : 'invalid',
            teamCount: this.teamAliases ? this.teamAliases.size : 0,
            lastUpdate: this.teamAliases ? new Date(this.teamAliases.values().next().value.lastUpdated).toLocaleString() : 'never'
        };
    }
};

window.wikiTeamModule = wikiTeamModule;

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: LICENSE.md
================
The MIT License (MIT)

Copyright (c) 2024 Kardiff

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: main-script.js
================
// ==UserScript==
// @name         Pigskin Enhancement Suite
// @namespace    http://tampermonkey.net/
// @version      1.0.0
// @description  Comprehensive enhancement suite for Pigskin Mania
// @author       Kardiff
// @match        http://pigskinmania.net/*
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/utils/storageUtils.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/utils/uiUtils.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/utils/pathValidator.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/spreadsModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/picksModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/lockModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/wikiTeamModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/timeModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/picksHistoryModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/userIdModule.js
// @require      https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/modules/standingsModule.js
// @grant        GM.setValue
// @grant        GM.getValue
// @grant        GM.xmlHttpRequest
// @downloadURL  https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/main-script.js
// @updateURL    https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/main-script.js
// ==/UserScript==

(async function() {
    'use strict';

    // Configuration
    const config = {
        debug: false,
        version: '1.0.0',
        repository: {
            owner: 'Kardiff-Kill-Team',
            name: 'Pigskin-Enhancement-Suite',
            branch: 'main',
            baseUrl: 'https://github.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite',
            rawBaseUrl: 'https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main'
        },
        modules: {
            spreads: {
                paths: ['/spreads/index.html'],
                enabled: true,
                version: '1.0.0'
            },
            picks: {
                paths: ['/forms/fbpicks.html'],
                enabled: true,
                version: '1.0.0'
            },
            standings: {
                paths: ['/standings/index.html'],
                enabled: true,
                version: '1.0.0'
            }
        },
        storage: {
            prefix: 'pses_',
            version: '1.0.0'
        },
        ui: {
            theme: {
                primary: '#007bff',
                success: '#28a745',
                warning: '#ffc107',
                danger: '#dc3545',
                info: '#17a2b8'
            },
            notifications: {
                duration: 3000,
                position: 'top-right'
            }
        }
    };

    // Module Manager
    class ModuleManager {
        constructor() {
            this.loadedModules = new Map();
            this.initializeUI();
        }

        initializeUI() {
            uiUtils.addStyles(`
                .psm-status {
                    position: fixed;
                    bottom: 10px;
                    left: 10px;
                    background: white;
                    padding: 5px 10px;
                    border-radius: 5px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                    font-size: 12px;
                    z-index: 9999;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                }

                .psm-status-dot {
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background: ${config.ui.theme.success};
                }

                .psm-status-text {
                    color: #333;
                }

                @media (max-width: 768px) {
                    .psm-status {
                        bottom: 5px;
                        left: 5px;
                        font-size: 10px;
                    }
                }
            `);

            const status = document.createElement('div');
            status.className = 'psm-status';
            status.innerHTML = `
                <span class="psm-status-dot"></span>
                <span class="psm-status-text">PigSkin Suite v${config.version}</span>
            `;
            document.body.appendChild(status);

            // Add version check
            this.checkVersion();
        }

        async checkVersion() {
            try {
                const response = await fetch(`${config.repository.rawBaseUrl}/version.json`);
                const versionInfo = await response.json();

                if (versionInfo.version !== config.version) {
                    uiUtils.showNotification(
                        'A new version is available. Please update your script.',
                        'info',
                        10000
                    );
                }
            } catch (error) {
                console.error('Version check failed:', error);
            }
        }

        async initialize() {
            const currentPath = window.location.pathname;

            // Initialize global utilities
            await storageUtils.initialize();
            await uiUtils.initialize();

            // Initialize page-specific modules
            for (const [moduleName, moduleConfig] of Object.entries(config.modules)) {
                if (moduleConfig.enabled && moduleConfig.paths.some(path => currentPath.includes(path))) {
                    await this.initializeModule(moduleName);
                }
            }

            // Log initialization in debug mode
            if (config.debug) {
                console.log('Initialized modules:', Array.from(this.loadedModules.keys()));
            }
        }

        async initializeModule(moduleName) {
            try {
                const module = window[moduleName + 'Module'];
                if (module) {
                    await module.initialize();
                    this.loadedModules.set(moduleName, true);
                    if (config.debug) {
                        console.log(`Initialized ${moduleName} module`);
                    }
                }
            } catch (error) {
                console.error(`Failed to initialize ${moduleName}:`, error);
                uiUtils.showNotification(
                    `Failed to initialize ${moduleName}. Some features may be unavailable.`,
                    'error'
                );
            }
        }

        getLoadedModules() {
            return Array.from(this.loadedModules.keys());
        }

        isModuleLoaded(moduleName) {
            return this.loadedModules.has(moduleName);
        }
    }

    // Error Handler
    window.addEventListener('error', (event) => {
        if (config.debug) {
            console.error('Script error:', event.error);
        }
        uiUtils.showNotification(
            'An error occurred. Please check the console for details.',
            'error'
        );
    });

    // Initialize
    try {
        const manager = new ModuleManager();
        await manager.initialize();
    } catch (error) {
        console.error('Failed to initialize Pigskin Suite:', error);
        uiUtils.showNotification(
            'Failed to initialize the enhancement suite.',
            'error'
        );
    }
})();

================
File: README.md
================
# Pigskin Enhancement Suite

A comprehensive enhancement suite for [PigSkin Mania](http://pigskinmania.net) that adds various quality-of-life improvements to the site.

## Features

### Spreads Page Enhancements
- **Time Zone Management**
    - Support for ET, CT, MT, AZ, and PT time zones
    - Auto-conversion of game times
    - Current time display in selected zone
- **Team Standardization**
    - Wikipedia-based team name normalization
    - Consistent team naming across pages
- **Visual Improvements**
    - Highlight your selected teams
    - Clear spread indicators

### Picks Form Features
- **Lock Management**
    - Dynamic lock dropdown updates
    - Visual lock status indicator
    - Lock validation and warnings
- **Game Time Validation**
    - Countdown timers for each game
    - Warnings for games that have started
    - Time zone aware validations
- **Picks History**
    - Track all your picks
    - Export to JSON or CSV
    - Historical performance statistics

### User Management
- **ID Management**
    - Save and auto-fill your user ID
    - Track recent IDs
    - Smart ID change detection
- **Settings Persistence**
    - Auto-fill preferences
    - Time zone preferences
    - Visual preferences

### Standings Page Features
- **Player Bookmarking**
    - Quick bookmark any player
    - Jump to bookmarked players
    - Search and filter capabilities
- **Visual Enhancements**
    - Highlight bookmarked players
    - Visual bookmark indicators
    - Flash animations for navigation

## Installation

1. Install a userscript manager:
    - [Chrome: Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)
    - [Firefox: Tampermonkey](https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/)
    - [Edge: Tampermonkey](https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd)

2. Install the script:
    - Click here to install: [Pigskin Enhancement Suite](https://raw.githubusercontent.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/main/main-script.js)
    - Click "Install" when prompted by Tampermonkey

The script will automatically update when new versions are released.

## Usage

The suite automatically activates on the following pages:

### Spreads Page (http://pigskinmania.net/spreads/index.html)
- Use time zone buttons to convert all times
- Hover over teams to see additional information
- Your picks from the current week are highlighted

### Picks Form (http://pigskinmania.net/forms/fbpicks.html)
- Spreads are automatically added to team names
- Lock dropdown updates based on your selections
- Warnings appear for games that have started
- ID is auto-filled if previously saved

### Standings Page (http://pigskinmania.net/standings/index.html)
- Click â˜… next to any player to bookmark them
- Use the bookmarks panel to quickly navigate
- Search players using the search box

## Development

To contribute to the development:

1. Clone the repository:
```bash
git clone https://github.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite.git
```

2. Repository Structure:
```
Pigskin-Enhancement-Suite/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ storageUtils.js     # Storage management utilities
â”‚   â”‚   â””â”€â”€ uiUtils.js          # UI helper functions
â”‚   â”œâ”€â”€ spreadsModule.js        # Spreads page functionality
â”‚   â”œâ”€â”€ picksModule.js          # Picks form enhancements
â”‚   â”œâ”€â”€ lockModule.js           # Lock selection management
â”‚   â”œâ”€â”€ wikiTeamModule.js       # Team name standardization
â”‚   â”œâ”€â”€ timeModule.js           # Time zone management
â”‚   â”œâ”€â”€ picksHistoryModule.js   # Historical picks tracking
â”‚   â”œâ”€â”€ userIdModule.js         # User ID management
â”‚   â””â”€â”€ standingsModule.js      # Standings page features
â”œâ”€â”€ LICENSE.md
â”œâ”€â”€ README.md
â””â”€â”€ main-script.js             # Main script entry point
```

3. Making Changes:
    - Each module is independent and follows a standard interface
    - Use the utility modules for common functionality
    - Test changes on all affected pages
    - Submit pull requests with clear descriptions

## Support

If you encounter issues or have suggestions:

1. Check existing [Issues](https://github.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/issues)
2. Create a new issue if needed
3. Include:
    - Browser and version
    - Tampermonkey version
    - Steps to reproduce
    - Expected vs actual behavior

## Credits

- NFL team data: Wikipedia
- Original site: PigSkin Mania (http://pigskinmania.net)
- Contributors: See [GitHub Contributors](https://github.com/Kardiff-Kill-Team/Pigskin-Enhancement-Suite/graphs/contributors)

## License

[MIT License](LICENSE.md) - Feel free to use and modify, but maintain attribution.

================
File: repo-structure.md
================
# Pigskin Mania Enhancement Suite

```
pigskin-enhancements/
â”œâ”€â”€ README.md
â”œâ”€â”€ main.js
â””â”€â”€ modules/
    â”œâ”€â”€ spreadsModule.js      // Spreads page enhancements
    â”œâ”€â”€ picksModule.js        // Picks form enhancements
    â”œâ”€â”€ lockModule.js         // Lock selection management
    â”œâ”€â”€ wikiTeamModule.js     // Team name standardization
    â”œâ”€â”€ timeModule.js         // Time zone and game time management
    â”œâ”€â”€ picksHistoryModule.js // Historical picks management
    â”œâ”€â”€ userIdModule.js       // User ID management
    â”œâ”€â”€ standingsModule.js    // Standings page enhancements
    â””â”€â”€ utils/
        â”œâ”€â”€ storageUtils.js   // Storage utilities
        â””â”€â”€ uiUtils.js        // UI utilities
```

## Installation

1. Install a userscript manager (e.g., Tampermonkey)
2. Install the main script from: `https://raw.githubusercontent.com/Kardiff-Kill-Team/pigskin-enhancements/main/main.js`



## Features

- Team name standardization using Wikipedia data
- Spreads synchronization between pages
- Lock selection management
- Multiple time zone support
- Picks history tracking
- User ID management
- Standings page enhancements
- Game time validation

## Development

Clone the repository:
```bash
git clone https://github.com/[username]/pigskin-enhancements.git
```

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
